# 数组

## <font color = blue> 内容概要:</font>

- 数组如何根据下标随机访问数组元素？
- 数组和链表的区别？
- 为什么数组的插入、删除操作比较低效？
- 数组访问越界会出现什么问题？
- 为什么数组访问从0开始编号？
- 容器和数组的比较？

##  <font color = blue>  遗留问题:</font>

1. 为什么无限循环输出`hello world` ？
2. 将删除集中一起执行的方法？



###  数组定义

**数组**（Array）是一种<font color = red>**线性表**</font>数据结构。它用一组<font color = red>**连续的**</font>内存空间，来存储一组具有<font color = red>**相同类型**</font>的数据。数组为了保持内存数据的连续性，会导致插入、删除这两个操作比较低效。

####  线性表

线性表就是数据排成像一条线一样的结构，每个线性表上的数据最多只有前和后两个方向。

![linear list](linear list.jpg)

#### 非线性表

在非线性表中，数据之间并不是简单的前后关系

![nonlinear list](nonlinear list.jpg)

计算机给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：

```
a[i]_address = base_address + i * data_type_size
```

**链表适合插入、删除，时间复杂度 O(1)；数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)**



###  低效的“插入”和“删除”

#### 插入

+ 数组中数据有序时，插入数据最好的时间复杂度为O(1)，最坏的时间复杂度为O(n)，平均时间复杂度为O(n)

+ 数组中数据无规律时，插入数据的时间复杂度可以降为O(1)。**该思想可以利用在快排中**

#### 删除

- 如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的数据，则最坏情况时间复杂度为 O(n)；平均情况时间复杂度也为 O(n)。

-  删除操作集中在一起执行，**JVM 标记清除垃圾回收算法**的核心思想  



### 警惕数组的访问越界问题

数组越界在 C 语言中是一种未决行为，并没有规定数组访问越界时编译器应该如何处理。因为，访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址是可用的，那么程序就可能不会报任何错误。

```c
//分析这段代码
int main(int argc, char* argv[]){
    int i = 0;
    int arr[3] = {0};
    for(; i<=3; i++){
        arr[i] = 0;
        printf("hello world\n");
    }
    return 0;
}
```

C语言中，数组越界检查的工作丢给程序员来做， Java 等语言会做越界检查。



### 容器和数组比较

1. 数据存储方式
   + 数组需要分配连续的内存空间，在定义数组时需要预先指定的大小。数据初始化之后，数组空间完全被利用。
   + 定义容器如`vector`也需要连续的存储空间，对于空间的申请和控制都由标准库帮我们管理。
2. 空间申请和占用
   + 数组在定义的时候已经指定了空间的大小，不能改变。如果我们申请了大小为 10 的数组，当第 11 个数据需要存储到数组中时，我们就需要重新分配一块更大的空间，将原来的数据复制过去，然后再将新的数据插入。
   + `vector`具有备用空间，支持动态扩容，空间利用率不是很高。如Java中容器类`ArrayList`，每次存储空间不够的时候，它都会将空间自动扩容为 1.5 倍大小。因为扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，如果事先能确定需要存储的数据大小，最好**在创建 `ArrayList` 的时候事先指定数据大小**。
3. 访问元素方式
   + 数组元素能使用下标和指针访问，下标的数据类型是:size_t。指针操作类似于迭代器。
   + vector可以使用迭代器和下标访问元素，下标访问的时候，下标的数据类型为vector::size_type
4. 附加操作
   + 容器操作提供了很多方法，容器可以将很多数组操作的细节封装起来，如数组插入、删除等。
   + 当要表示多维数组时，用数组往往会更加直观。比如 `Object[][] array`；而用容器的话则需要这样定义：`ArrayList<ArrayList<object> > array`

总结：对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果是做一些非常底层的开发，比如开发网络框架，性能的优化，执行效率等需要做到极致，这个时候数组就会优于容器，成为首选。



