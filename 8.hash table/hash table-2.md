# 散列表

## <font color = blue>内容概要</font>

1. 散列表原理
2. 如何解决散列冲突问题

## <font color = blue>遗留问题</font>





### 链表和散列表的组合使用

+ 在链表中，学会如何用链表来实现 LRU 缓存淘汰算法，但是链表实现的 LRU 缓存淘汰算法的时间复杂度是 O(n)，通过散列表可以将这个时间复杂度降低到 O(1)。
+ 在跳表那一节，提到 Redis 的有序集合是使用跳表来实现的，跳表可以看作一种改进版的链表。Redis 有序集合不仅使用了跳表，还用到了散列表。
+ 除此之外， Java 编程语言中 LinkedHashMap 这样一个常用的容器，也用到了散列表和链表两种数据结构。



### LRU 缓存淘汰算法

+ 在链表那一节中，提到借助散列表，可以把 LRU 缓存淘汰算法的时间复杂度降低为 O(1)。

+ 回顾一下是如何通过链表实现 LRU 缓存淘汰算法的。

  + 首先，需要维护一个按照访问时间从大到小有序排列的链表结构。因为缓存大小有限，当缓存空间不够，需要淘汰一个数据的时候，就直接将链表头部的结点删除。
  + 当要缓存某个数据的时候，先在链表中查找这个数据。如果没有找到，则直接将数据放到链表的尾部；如果找到了，就把它移动到链表的尾部。因为查找数据需要遍历链表，所以单纯用链表实现的 LRU 缓存淘汰算法的时间复杂很高，是 O(n)。

+ 一个缓存（cache）系统主要包含下面这几个操作

  + 往缓存中添加一个数据；

  + 从缓存中删除一个数据；

  + 在缓存中查找一个数据。

  + 这三个操作都要涉及“查找”操作，如果单纯地采用链表的话，时间复杂度只能是 O(n)。如果将散列表和链表两种数据结构组合使用，可以将这三个操作的时间复杂度都降低到 O(1)。具体的结构就是下面这个样子：

    + 使用双向链表存储数据，链表中的每个结点处理存储数据（data）、前驱指针（prev）、后继指针（next）之外，还新增了一个特殊的字段 hnext。这个 hnext 有什么作用呢？
    + 因为我们的散列表是通过链表法解决散列冲突的，所以每个结点会在两条链中。一个链是刚刚我们提到的**双向链表**，另一个链是散列表中的**拉链**。**前驱和后继指针是为了将结点串在双向链表中，hnext 指针是为了将结点串在散列表的拉链中**。

    ![](9.jpg)

