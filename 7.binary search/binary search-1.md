# 二分查找

## <font color = blue>内容概要</font>

1. 二分法的思想

2. 

   

## <font color = blue> 遗留问题</font>





### 二分查找（Binary Search）

+ 二分思想

  + 针对有序数据集合的查找算法：二分查找算法，也叫折半查找算法。
  + 二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。

+ 时间复杂度分析

  + 假设数据大小是 n，每次查找后数据都会缩小为原来的一半，也就是会除以 2。最坏情况下，直到查找区间被缩小为空，才停止

    ![](1.jpg)

    + 这是一个等比数列。其中$ n/2^k=1$ 时，k 的值就是总共缩小的次数。而每一次缩小操作只涉及两个数据的大小比较，所以，经过了 k 次区间缩小操作，时间复杂度就是 O(k)。通过$ n/2^k=1$，我们可以求得 $k=log2^n$，所以时间复杂度就是 $O(logn)$。
    + 二分查找是目前为止遇到的第一个时间复杂度为 $O(logn)$的算法。这是一种极其高效的时间复杂度，有的时候甚至比时间复杂度是常量级 O(1) 的算法还要高效。

  + 对数时间复杂度。

    + 因为$ logn$ 是一个非常“恐怖”的数量级，即便 n 非常非常大，对应的$ logn$ 也很小。比如 n 等于 2 的 32 次方，这个数很大了吧？大约是 42 亿。也就是说，如果我们在 42 亿个数据中用二分查找一个数据，最多需要比较 32 次。
    + 用大 O 标记法表示时间复杂度的时候，会省略掉常数、系数和低阶。对于常量级时间复杂度的算法来说，O(1) 有可能表示的是一个非常大的常量值，比如 O(1000)、O(10000)。所以，常量级时间复杂度的算法有时候可能还没有 $O(logn)$ 的算法执行效率高。
    + 反过来，对数对应的就是指数。有一个非常著名的“阿基米德与国王下棋的故事”，感受一下指数的“恐怖”。这也是为什么，指数时间复杂度的算法在大规模数据面前是无效的。



### 二分查找的递归与非递归实现

+ **最简单的情况就是有序数组中不存在重复元素**，用二分查找值等于给定值的数据。

  ```java
  public int bsearch(int[] a, int n, int value) {
  	int low = 0;
    	int high = n - 1;
  
   	 while (low <= high) {
      	int mid = (low + high) / 2;
      	if (a[mid] == value) {
        		return mid;
      	} else if (a[mid] < value) {
        		low = mid + 1;
      	} else {
        		high = mid - 1;
      	}
    	}
    	return -1;
  }
  ```

  + low、high、mid 都是指数组下标，其中 low 和 high 表示当前查找的区间范围，初始 low=0， high=n-1。mid 表示[low, high]的中间位置。
  + 通过对比 a[mid]与 value 的大小，来更新接下来要查找的区间范围，直到找到或者区间缩小为 0，就退出。

+ 用循环实现二分，容易出错的 3 个地方

  + 循环退出条件
    + 注意是 low<=high，而不是 low<high。
  + mid 的取值
    + 实际上，mid=(low+high)/2 这种写法是有问题的。因为如果 low 和 high 比较大的话，两者之和就有可能会溢出。
    + 改进的方法是将 mid 的计算方式写成 low+(high-low)/2。
    + 更进一步，如果要将性能优化到极致的话，我们可以将这里的除以 2 操作转化成位运算 low+((high-low)>>1)。因为相比除法运算来说，计算机处理位运算要快得多。
  + low 和 high 的更新
    + low=mid+1，high=mid-1。注意这里的 +1 和 -1，如果直接写成 low=mid 或者 high=mid，就可能会发生死循环。比如，当 high=3，low=3 时，如果 a[3]不等于 value，就会导致一直循环不退出。

+ 用递归实现二分法

  ```java
  // 二分查找的递归实现
  public int bsearch(int[] a, int n, int val) {
    return bsearchInternally(a, 0, n - 1, val);
  }
  
  private int bsearchInternally(int[] a, int low, int high, int value) {
    if (low > high) return -1;
  
    int mid =  low + ((high - low) >> 1);
    if (a[mid] == value) {
      return mid;
    } else if (a[mid] < value) {
      return bsearchInternally(a, mid+1, high, value);
    } else {
      return bsearchInternally(a, low, mid-1, value);
    }
  }
  ```



### 二分查找应用场景的局限性

+ 前面分析过，二分查找的时间复杂度是 $O(logn)$，查找数据的效率非常高。不过，并不是什么情况下都可以用二分查找，它的应用场景是有很大局限性的。那什么情况下适合用二分查找，什么情况下不适合呢？
+ 首先，二分查找依赖的是顺序表结构，简单点说就是数组。
  + 那二分查找能否依赖其他数据结构呢？比如链表。答案是不可以的，主要原因是二分查找算法需要按照下标随机访问元素。数组按照下标随机访问数据的时间复杂度是 O(1)，而链表随机访问的时间复杂度是 O(n)。所以，如果数据使用链表存储，二分查找的时间复杂就会变得很高。
  + 二分查找只能用在数据是通过顺序表来存储的数据结构上。如果你的数据是通过其他数据结构存储的，则无法应用二分查找。
+ 其次，二分查找针对的是有序数据。
  + 二分查找对这一点的要求比较苛刻，数据必须是有序的。
  + 如果数据没有序，需要先排序。排序的时间复杂度最低是$ O(nlogn)$。所以，如果我们针对的是一组静态的数据，没有频繁地插入、删除，我们可以进行一次排序，多次二分查找。这样排序的成本可被均摊，二分查找的边际成本就会比较低。
  + 但是，如果数据集合有频繁的插入和删除操作，要想用二分查找，要么每次插入、删除操作之后保证数据仍然有序，要么在每次二分查找之前都先进行排序。针对这种动态数据集合，无论哪种方法，维护有序的成本都是很高的。
  + 所以，二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中。针对动态变化的数据集合，二分查找将不再适用。
+ 再次，数据量太小不适合二分查找
  + 如果要处理的数据量很小，完全没有必要用二分查找，顺序遍历就足够了。比如我们在一个大小为 10 的数组中查找一个元素，不管用二分查找还是顺序遍历，查找速度都差不多。只有数据量比较大的时候，二分查找的优势才会比较明显。
  + 不过，这里有一个例外。如果数据之间的比较操作非常耗时，不管数据量大小，都推荐使用二分查找。比如，数组中存储的都是长度超过 300 的字符串，如此长的两个字符串之间比对大小，就会非常耗时。我们需要尽可能地减少比较次数，而比较次数的减少会大大提高性能，这个时候二分查找就比顺序遍历更有优势。

+ 最后，数据量太大也不适合二分查找
  + 二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求内存空间连续，对内存的要求比较苛刻。
  + 比如，我们有 1GB 大小的数据，如果希望用数组来存储，那就需要 1GB 的连续内存空间。注意这里的“连续”二字，也就是说，即便有 2GB 的内存空间剩余，但是如果这剩余的 2GB 内存空间都是零散的，没有连续的 1GB 大小的内存空间，那照样无法申请一个 1GB 大小的数组。
  + 而二分查找是作用在数组这种数据结构之上的，所以太大的数据用数组存储就比较吃力了，也就不能用二分查找了。